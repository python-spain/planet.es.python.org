<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" lang="es">








<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="noarchive" />
    <meta http-equiv="Refresh" content="1800" />
    <link rel="shortcut icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <link rel="alternate" type="application/rss+xml" title="
    planet.es.python.org
" href="/rss.xml" />
    <title>
    planet.es.python.org
</title>
</head>
<body id="rawdog">
<div id="header">
    <h1><a href="/" style="color: black;">planet.<span style="color:#d40000">e</span><span style="color:#f3b52c">s</span>.<span style="color:#43648b">pyt</span><span style="color:#f3b52c">hon</span>.org</a></h1>
</div>
<div id="items">
<div class="day">
<h2>mi&#233;rcoles, 13 marzo</h2>
<div class="time">
<h3>15:55</h3>
<div class="item feed-207d1418 feed-{feed_id}" id="item-eed4e6aa">
<p class="itemheader">
<span class="itemtitle">
    El Ornitorrinco Enmascarado:
<a href="http://www.elornitorrincoenmascarado.com/2013/03/como-escribir-una-calculadora-en-70.html">Como escribir una calculadora en 70 l&#237;neas de Python, mediante un analizador descendente recursivo</a></span>
</p>
    <div class="itemdescription">
    <p>Este post es una traducci&#243;n del art&#237;culo original de Erez, publicado en su blog <a class="reference external" href="http://blog.erezsh.com/">Stories For Sad Robots</a>. El original puede consultarse aqu&#237;:</p><blockquote><a class="reference external" href="http://blog.erezsh.com/how-to-write-a-calculator-in-70-python-lines-by-writing-a-recursive-descent-parser/">http://blog.erezsh.com/how-to-write-a-calculator-in-70-python-lines-by-writing-a-recursive-descent-parser/</a></blockquote><p>Hay referencias a un art&#237;culo anterior, si alguien est&#225; interesado un que lo traduzca tambi&#233;n que me deje un comentario y se har&#225; lo que se pueda.</p> <a href="http://4.bp.blogspot.com/-ix3e1f6rBTA/UT8wKsafRHI/AAAAAAAACDs/v0f3TgxTVPE/s1600/open_quote.png"><img alt="Empieza la traducci&#243;n" border="0" height="40" src="http://4.bp.blogspot.com/-ix3e1f6rBTA/UT8wKsafRHI/AAAAAAAACDs/v0f3TgxTVPE/s320/open_quote.png" width="48" /></a> <p>Hace tres meses, escrib&#237; un post detallando el proceso de implementar una calculadora usando una librer&#237;a de <em>parsing</em>. La respuesta popular, sin embargo, mostr&#243; que la mayor&#237;a de los lectores estaban m&#225;s interesados en ver una calculadora implementada desde cero, usando solo las &quot;pilas incluidas&quot;. Y me dije &#191;Por qu&#233; no?</p><p>Implementar una calculadora es f&#225;cil, si usas algunos trucos espec&#237;ficos de las expresiones aritm&#233;ticas, pero usar estos trucos siempre produce lo mismo: La soluci&#243;n pierde elegancia, no se puede extender y se hace dif&#237;cil de comprender intuitivamente. Como parec&#237;a un desaf&#237;o interesante, y puede conducir a un post &#250;til, he decidido escribirlo usando un <strong>analizador descendente recursivo</strong> (<a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> en wikipedia) gen&#233;rico. Con la mismo filosof&#237;a de la vez anterior, quiero mantener el menor n&#250;mero de l&#237;neas que sea razonable, as&#237; que el c&#243;digo estar&#225; lleno de trucos y <em>hacks</em>, pero estar&#225;n a un nivel superficial y no ser&#225;n espec&#237;ficos de la tarea que tenemos entre manos.</p><p>Este art&#237;culo es una explicaci&#243;n detallada, paso a paso, de la implementaci&#243;n. Si quieres pasar directamente al c&#243;digo e intentar entenderlo por tu cuenta, solo tienes que ir a la &#250;ltima parte. Con suerte una vez le&#237;do y entendido el art&#237;culo tendr&#225;s una mejor comprensi&#243;n del funcionamiento interno de un analizador sint&#225;ctico. Luego puedes incluso utilizar una librer&#237;a de an&#225;lisis sint&#225;ctico de verdad y ahorrarte todos estos enojosos detalles.</p><p>Para entender este art&#237;culo, hace  falta tener un conocimiento m&#225;s o menos completo de Python, y es recomendable tener al menos una idea de lo que son los analizadores sint&#225;cticos o <strong>parsers</strong> y para que sirven. Si no est&#225;s seguro, te recomiendo que leas el art&#237;culo anterior <a class="reference external" href="http://blog.erezsh.com/how-to-write-a-calculator-in-50-python-lines-without-eval/">How To Write A Calculator in 50 Python Lines (Without Eval)</a>, en el que se explica la gram&#225;tica que usaremos aqu&#237;.</p><div class="section" id="paso-1-tokenizar-tokenize"><h1>Paso 1: Tokenizar (Tokenize)</h1><p>Para poder evaluar una expresi&#243;n, el primer paso ser&#225; convertirla en una lista de s&#237;mbolos individuales, o <strong>tokens</strong>. Esta es la parte m&#225;s f&#225;cil, y no es el tema central de inter&#233;s en este art&#237;culo, as&#237; que haremos un poco de trampa para facilitar las cosas.</p><p>En primer lugar, definiremos los <em>tokens</em> (Se observar&#225; que falta la definici&#243;n de n&#250;meros, eso es porque vamos a considerarlos el valor por defecto):</p> <div class="highlight"><pre><span class="n">token_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">'+'</span><span class="p">:</span><span class="s">'ADD'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span><span class="s">'ADD'</span><span class="p">,</span><br />             <span class="s">'*'</span><span class="p">:</span><span class="s">'MUL'</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span><span class="s">'MUL'</span><span class="p">,</span><br />             <span class="s">'('</span><span class="p">:</span><span class="s">'LPAR'</span><span class="p">,</span> <span class="s">')'</span><span class="p">:</span><span class="s">'RPAR'</span><span class="p">}</span><br /><span class="n">Token</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Token'</span><span class="p">,</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'value'</span><span class="p">])</span><br /></pre></div>  <p>Y este es el c&#243;digo que usaremos para <em>tokenizar</em> una expresi&#243;n dada, <tt class="docutils literal">expr</tt>:</p> <div class="highlight"><pre><span class="n">split_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[\d.]+|[</span><span class="si">%s</span><span class="s">]'</span> <span class="o">%</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_map</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span><br /><span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">Token</span><span class="p">(</span><span class="n">token_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'NUM'</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">split_expr</span><span class="p">]</span><br /></pre></div>  <p>La primera l&#237;nea es un truco que divide la expresi&#243;n en sus componentes b&#225;sicos, de forma que:</p> <pre class="literal-block"><br />'1.2 / ( 11+3)' --&gt; ['1.2', '/', '(', '11', '+', '3', ')']<br /></pre> <p>La siguiente l&#237;nea asigna nombres a los <em>tokens</em>, para que el parser pueda reconocerlos por categor&#237;a:</p><pre class="literal-block"><br />['1.2', '/', '(', '11', '+', '3', ')']<br />--&gt;<br />[Token(name='NUM', value='1.2'), Token(name='MUL', value='/'),<br />Token(name='LPAR', value='('), Token(name='NUM', value='11'),<br />Token(name='ADD', value='+'), Token(name='NUM', value='3'),<br />Token(name='RPAR', value=')')]<br /></pre> <p>Se asume que cualquier <em>token</em> que no est&#233; en el diccionario <tt class="docutils literal">token_map</tt>corresponder&#225; a un n&#250;mero. Nuestro tokenizador carece de la virtud de la <em>validaci&#243;n</em>, que evitar&#237;a que se aceptaran cosas que no fueran n&#250;meros, pero por suerte el evaluador realizar&#225; m&#225;s tarde esta tarea por nosotros.</p> <p>Ahora que ya tenemos una lista de <em>tokens</em>, nuestro siguiente paso ser&#225; <em>parsearlo</em> para obtener un <a class="reference external" href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>.</p></div> <div class="section" id="paso-2-definir-la-gramatica"><h1>Paso 2: Definir la gram&#225;tica</h1> <p>El parser que usaremos en esta implementaci&#243;n es un versi&#243;n un tanto ingenua de <strong>parser recursivo descendente</strong> (<a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>), que  es una versi&#243;n simplificada del parser LL (<a class="reference external" href="http://en.wikipedia.org/wiki/LL_parser">LL parser</a>). Este tipo de parser es el m&#225;s f&#225;cil de implementar, y de hecho solo nos ocupar&#225; unas 14 l&#237;neas de c&#243;digo. Es un tipo de parser descendente, lo que significa que primero intenta emparejar la regla m&#225;s alta (como <tt class="docutils literal">expression</tt>), y continua de forma recursiva intentado emparejar subreglas hasta que alcanza las reglas de m&#225;s bajo nivel (como por ejemplo, <tt class="docutils literal">number</tt>). Para expresarlo de otra manera, mientras que un parser ascendente (Como un <a class="reference external" href="http://en.wikipedia.org/wiki/LR_parser">LR Parser</a> o <a class="reference external" href="http://es.wikipedia.org/wiki/Analizador_sint%C3%A1ctico_LR">Analizador sint&#225;ctico LR</a> en espa&#241;ol) intenta de forma gradual &quot;plegar&quot; o &quot;comprimir&quot; tokens y reglas dentro de otras reglas, hasta que solo quede una, un parser descendente ir&#225; expandiendo las reglas, usando cada vez reglas menos abstractas, hasta el punto en que haya emparejado completamente los <em>tokens</em> de entrada.</p><p>Pero antes de entrar en materia con el parser, hablemos un poco de la gram&#225;tica. En el post anterior usamos un parser LR, y se defini&#243; la gram&#225;tica as&#237; (las may&#250;sculas son tokens):</p> <pre class="literal-block"><br />add: add ADD mul | mul;<br />mul: mul MUL atom | atom;<br />atom: NUM | '(' add ')' | neg;<br />neg: '-' atom;<br /></pre> <div class="note"><p class="first admonition-title">Note</p><p class="last">Si no entiendes esta gram&#225;tica, deber&#237;as leer el art&#237;culo anterior: <a class="reference external" href="http://blog.erezsh.com/how-to-write-a-calculator-in-50-python-lines-without-eval/">How To Write A Calculator in 50 Python Lines (Without Eval)</a>.</p></div> <p>esta vez usaremos un parser LL, as&#237; que definiremos la gram&#225;tica de esta otra forma:</p><pre class="literal-block"><br />rule_map = {<br />    'add' : ['mul ADD add', 'mul'],<br />    'mul' : ['atom MUL mul', 'atom'],<br />    'atom': ['NUM', 'LPAR add RPAR', 'neg'],<br />    'neg' : ['ADD atom'],<br />}<br /></pre><p>Hay un cambio sutil: Las definiciones recursivas de <tt class="docutils literal">add</tt> y <tt class="docutils literal">mul</tt>est&#225;n invertidas. Este detalle es muy importante, y necesita su aclaraci&#243;n.</p><p>La versi&#243;n LR de esta gram&#225;tica usa lo que se llama recursividad por la izquierda (<a class="reference external" href="http://en.wikipedia.org/wiki/Left_recursion">left recursion</a> en ingl&#233;s). Cuando un parser LL se encuentra con una llamada recursiva, la ejecuta de inmediato, en un intento de emparejar la regla que est&#225; utilizando, por lo que puede entrar en un bucle infinito. <a class="reference external" href="http://www.antlr.org/wiki/display/ANTLR3/Left-Recursion+Removal">Incluso parsers LL bastante avanzados como ANTLR se enfrentan a esta problema</a>, aunque probablemente, en vez de dar vueltas indefinidamente, como hace nuestro parser de juguete, terminar&#225;n con un conveniente  mensaje de error .</p><p>La recursividad por la izquierda se soluciona de forma sencilla cambi&#225;ndola por recursividad por la derecha, que es justo lo que acabamos de hacer con nuestro sutil cambio. Pero como nada en la vida es f&#225;cil cuando tratamos con <em>parsers</em>, se ha creado otro problema: Mientras que la recursividad por la izquierda analiza <tt class="docutils literal"><span class="pre">3-2-1</span></tt> <em>correctamente</em> como <tt class="docutils literal"><span class="pre">(3-2)-1</span></tt>, la recursividad por la derecha lo analiza, de forma <em>incorrecta</em>, como <tt class="docutils literal"><span class="pre">3-(2-1)</span></tt>. No s&#233; como solucionar esto de forma f&#225;cil, as&#237; que para mantener las cosas sencillas he optado por mantener la forma incorrecta y resolverlo en una etapa posterior (v&#233;ase el paso 4).</p></div><div class="section" id="paso-3-obtener-un-ast-arbol-de-sintaxis-abstracta"><h1>Paso 3: Obtener un AST (&#193;rbol de Sintaxis Abstracta)</h1><p>El algoritmo es sencillo. Vamos a definir una funci&#243;n recursiva que acepta dos par&#225;metros: El primero es el nombre de la regla que estamos intentando capturar, y el segundo es una lista de los tokens que nos quedan por comprobar. Empezaremos con <tt class="docutils literal">add</tt>, -que es la regla m&#225;s alta- y con la lista de todos los <em>tokens</em>, y haremos que las sucesivas llamadas recursivas sean cada vez m&#225;s espec&#237;ficas. La funci&#243;n  retorna una tupla: La correspondencia encontrada y una lista de los <em>tokens</em> que faltan por comprobar. Con el prop&#243;sitos de reducir en lo posible el c&#243;digo, este ser&#225; capaz de encontrar <em>tokens</em> tambi&#233;n (En los dos casos son cadenas de texto: en un caso con todas las letras en may&#250;sculas y en el otro con todas las letras en min&#250;sculas).</p><p>Este es el c&#243;digo del <em>parser</em>:</p> <div class="highlight"><pre><span class="n">RuleMatch</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'RuleMatch'</span><span class="p">,</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'matched'</span><span class="p">])</span><br /><br /><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span><br />    <span class="k">if</span> <span class="n">tokens</span> <span class="ow">and</span> <span class="n">rule_name</span> <span class="o">==</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>      <span class="c"># Match a token?</span><br />        <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><br />    <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">rule_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="p">()):</span>   <span class="c"># Match a rule?</span><br />        <span class="n">remaining_tokens</span> <span class="o">=</span> <span class="n">tokens</span><br />        <span class="n">matched_subrules</span> <span class="o">=</span> <span class="p">[]</span><br />        <span class="k">for</span> <span class="n">subrule</span> <span class="ow">in</span> <span class="n">expansion</span><span class="o">.</span><span class="n">split</span><span class="p">():</span><br />            <span class="n">matched</span><span class="p">,</span> <span class="n">remaining_tokens</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">subrule</span><span class="p">,</span> <span class="n">remaining_tokens</span><span class="p">)</span><br />            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span><br />                <span class="k">break</span>   <span class="c"># no such luck. next expansion!</span><br />            <span class="n">matched_subrules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span><br />        <span class="k">else</span><span class="p">:</span><br />            <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="n">matched_subrules</span><span class="p">),</span> <span class="n">remaining_tokens</span><br />    <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>   <span class="c"># match not found</span><br /></pre></div> <p>Las l&#237;neas 4-5 comprueban si <tt class="docutils literal">rule_name</tt> es realmente un <em>token</em>, y si coincide con el <em>token</em> actual. Si lo hace, devuelve la coincidencia, junto con el resto de los <em>tokens</em> que aun faltan por consumir.</p><p>La l&#237;nea 6 itera sobre las subreglas de <tt class="docutils literal">rule_name</tt>, de forma que cada una pueda ser analizada recursivamente. Si <tt class="docutils literal">rule_name</tt> es un <em>token</em>, la llamada a <tt class="docutils literal">get()</tt> devolver&#225; una tupla vac&#237;a y el c&#243;digo continuar&#225; hasta alcanzar el return final, que devuelve una tupla sin valores.</p><p>Las l&#237;neas 9-14 iteran sobre cada elemento de la subregla actual, e intenta hacerlas coincidir de forma secuencial. Cada iteraci&#243;n intenta consumir tantos <em>tokens</em> como le sea posible. Si un elemento no coincide, se descarta toda la regla. Si, por el contrario, se consigue casar todos los elementos, alcanzaremos la cl&#225;usula <tt class="docutils literal">else</tt> y devolveremos nuestra coincidencia para <tt class="docutils literal">rule_name</tt>, junto con el resto de <em>tokens</em> que faltan por casar.</p><p>Vamos a ejecutarlo con <tt class="docutils literal">1.2 / ( 11+3)</tt> como entrada:</p><pre class="literal-block"><br />&gt;&gt;&gt; tokens = [Token(name='NUM', value='1.2'), Token(name='MUL', value='/'),<br />              Token(name='LPAR', value='('), Token (name='NUM', value='11'),<br />              Token(name='ADD', value='+'), Token(name='NUM', value='3'),<br />              Token(name='RPAR', value=')')]<br />&gt;&gt;&gt; match('add', tokens)<br />(RuleMatch(name='add', matched=[RuleMatch(name='mul',<br />matched=[RuleMatch(name='atom', matched=[Token(name='NUM', value='1.2')]),<br />Token(name='MUL', value='/'), RuleMatch(name='mul',<br />matched=[RuleMatch(name='atom', matched=[Token(name='LPAR',<br />value='('), RuleMatch(name='add', matched=[RuleMatch(name='mul',<br />matched=[RuleMatch(name='atom', matched=[Token(name='NUM', value='11')])]),<br />Token(name='ADD', value='+'), RuleMatch(name='add',<br />matched=[RuleMatch(name='mul', matched=[RuleMatch(name='atom',<br />matched=[Token(name='NUM', value='3')])])])]), Token(name='RPAR',<br />value=')')])])])]), [])<br /></pre><p>El resultado es una tupla, como era de esperar, y podemos ver que no queda ning&#250;n token para analizar. La coincidencia actual no es f&#225;cil de leer, vamos a representarla gr&#225;ficamente para que se entienda mejor:</p><pre class="literal-block"><br />add<br />    mul<br />        atom<br />            NUM '1.2'<br />        MUL '/'<br />        mul<br />            atom<br />                LPAR    '('<br />                add<br />                    mul<br />                        atom<br />                            NUM '11'<br />                    ADD '+'<br />                    add<br />                        mul<br />                            atom<br />                                NUM '3'<br />                RPAR    ')'<br /></pre><p>Esta es la pinta que presenta un AST, en concepto. Es una buena pr&#225;ctica ejecutar mentalmente el <em>parser</em>, o quiz&#225; con la ayuda de papel. Me atrever&#237;a a decir que es necesario si realmente quieres entenderlo. Puedes usar este AST como referencia para asegurarte de que lo est&#225;s haciendo bien.</p><p>En este punto, henos escrito un <em>parser</em> capaz de analizar correctamente operaciones binarias, operadores unitarios, par&#233;ntesis y precedencia,</p><p>Solo hay una cosa que hace mal, y vamos a arreglarla a continuaci&#243;n.</p></div><div class="section" id="paso-4-post-procesado"><h1>Paso 4: Post Procesado</h1><p>El <em>parser</em> no es perfecto en muchos aspectos. El m&#225;s importante ahora es que no puede manejar la recursividad por la izquierda, lo que obliga a que la gram&#225;tica sea recursiva derecha. En consecuencia, analizar la cadena <tt class="docutils literal">8/4/2</tt>nos genera el siguiente AST:</p><pre class="literal-block"><br />add<br />    mul<br />        atom<br />            NUM 8<br />        MUL '/'<br />        mul<br />            atom<br />                NUM 4<br />            MUL '/'<br />            mul<br />                atom<br />                    NUM 2<br /></pre><p>Si intentamos resolver esta expresi&#243;n con este &#225;rbol, tendr&#237;amos que calcular primero <tt class="docutils literal">4/2</tt>, que es incorrecto. Algunos parsers LL eligen arreglar la asociatividad en el &#225;rbol. Pero esto llevar&#237;a demasiadas l&#237;neas ;). En vez de eso, lo que vamos a hacer en &quot;aplanarlo&quot;. El m&#233;todo es sencillo: Para cada regla en el AST que:</p><blockquote><ol class="arabic simple"><li>necesite ser arreglada,</li><li>sea una operaci&#243;n binaria (tiene tres subreglas), y</li><li>el operando por la derecha resulta ser la misma regla</li></ol></blockquote><p>entonces &quot;aplanaremos&quot; la &#250;ltima en la primera. Por &quot;aplanar&quot; quiero decir reemplazar un nodo por sus hijos, en el contexto de su padre. Como nuestro recorrido por el &#225;rbol es DFS post-order, esto significa que empieza por los bordes del &#225;rbol y va progresando hacia la ra&#237;z, de forma que los efectos son acumulativos. Este es el c&#243;digo:</p> <div class="highlight"><pre><span class="n">fix_assoc_rules</span> <span class="o">=</span> <span class="s">'add'</span><span class="p">,</span> <span class="s">'mul'</span><br /><br /><span class="k">def</span> <span class="nf">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span><br />    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">matched</span><span class="p">)</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">rule_map</span> <span class="k">else</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><br /><br /><span class="k">def</span> <span class="nf">flatten_right_associativity</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span><br />    <span class="n">new</span> <span class="o">=</span> <span class="n">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">flatten_right_associativity</span><span class="p">)</span><br />    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">fix_assoc_rules</span><br />        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><br />        <span class="ow">and</span> <span class="n">new</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><br />            <span class="n">new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">matched</span><br />    <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><br /></pre></div>  <p>Este c&#243;digo convertir&#225; cualquier composici&#243;n secuencial de sumas o multiplicaciones en una lista plana (sin mezclar unas con otras). Los par&#233;ntesis rompen la secuencia, por supuesta, as&#237; que no se ven afectados.</p><p>A partir de aqu&#237; se <em>podr&#237;a</em> reconstruir la estructura en forma asociativa por la izquierda, usando c&#243;digo como:</p> <div class="highlight"><pre><span class="k">def</span> <span class="nf">build_left_associativity</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span><br />    <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">build_left_associativity</span><span class="p">)</span><br />    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">fix_assoc_rules</span><span class="p">:</span><br />        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="mi">3</span><span class="p">:</span><br />            <span class="n">new_nodes</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">RuleMatch</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">[:</span><span class="mi">3</span><span class="p">])]</span><br />    <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">)</span><br /></pre></div> <p>Pero no lo vamos a hacer. Queremos reducir el n&#250;mero de l&#237;neas de c&#243;digo, y cambiar el c&#243;digo de evaluaci&#243;n para que pueda manejar listas conlleva menos l&#237;neas que reconstruir el &#225;rbol.</p> <div class="note"><p class="first admonition-title">Nota</p><p class="last">DFS post order: DFS significa &quot;b&#250;squeda  en profundidad&quot;, y significa que a medida que recorremos el &#225;rbol, se visitan primero los nodos que est&#225;n en los niveles inferiores (O, dicho de otra manera, los m&#225;s profundos). Hay dos tipos de b&#250;squedas en profundidad, en preorden o postorden. La diferencia entra las dos es el momento en que se a&#241;ade un nodo a la salida, antes o despu&#233;s de visitarlo)</p></div></div><div class="section" id="paso-5-evaluar"><h1>Paso 5: Evaluar</h1><p>Evaluar el &#225;rbol es muy sencillo. Lo &#250;nico que hace falta es navegar por &#233;l de forma similar a como lo hicimos en el c&#243;digo de post-proceso (Es decir, DFS post-order) y evaluar cada regla que nos encontramos. Como hemos evaluado primero los nodos m&#225;s profundos, cada vez que alcanzamos un nodo de tipo regla, sus hijos no pueden ser otra cosa m&#225;s que n&#250;meros. Este es el c&#243;digo:</p> <div class="highlight"><pre><span class="n">bin_calc_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">'*'</span><span class="p">:</span><span class="n">mul</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span><span class="n">div</span><span class="p">,</span> <span class="s">'+'</span><span class="p">:</span><span class="n">add</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span><span class="n">sub</span><span class="p">}</span><br /><br /><span class="k">def</span> <span class="nf">calc_binary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span><br />    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">:</span><br />        <span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">bin_calc_map</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">]</span><br />    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><br /><br /><span class="n">calc_map</span> <span class="o">=</span> <span class="p">{</span><br />    <span class="s">'NUM'</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span><br />    <span class="s">'atom'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">],</span><br />    <span class="s">'neg'</span> <span class="p">:</span> <span class="k">lambda</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="n">num</span><span class="p">):</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="o">-</span><span class="n">num</span><span class="p">)[</span><span class="n">op</span><span class="o">==</span><span class="s">'-'</span><span class="p">],</span><br />    <span class="s">'mul'</span> <span class="p">:</span> <span class="n">calc_binary</span><span class="p">,</span><br />    <span class="s">'add'</span> <span class="p">:</span> <span class="n">calc_binary</span><span class="p">,</span><br /><span class="p">}</span><br /><br /><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span><br />    <span class="n">solutions</span> <span class="o">=</span> <span class="n">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">)</span><br />    <span class="k">return</span> <span class="n">calc_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">)(</span><span class="n">solutions</span><span class="p">)</span><br /></pre></div>  <p>Hemos escrito <tt class="docutils literal">calc_binary</tt> para que eval&#250;e tanto la suma como la multiplicaci&#243;n (y sus contrapartidas). Tambi&#233;n eval&#250;a listas, dado el caso, de manera asociativa por la izquierda. De esa forma resolvemos el problema que ten&#237;amos con nuestra peque&#241;a gram&#225;tica LL.</p></div> <div class="section" id="paso-6-el-repl-readevalprint-loop"><h1>Paso 6: El REPL (Read&#8211;Eval&#8211;Print Loop)</h1><p>La forma m&#225;s sencilla posible ser&#237;a:</p> <div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span><br />    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span><br />        <span class="k">print</span><span class="p">(</span> <span class="n">calc</span><span class="p">(</span><span class="nb">raw_input</span><span class="p">(</span><span class="s">'&amp;gt; '</span><span class="p">))</span> <span class="p">)</span><br /></pre></div>  <p>Que no precisa m&#225;s explicaci&#243;n. Espero :)</p></div><div class="section" id="apendice-todo-el-codigo-en-uno-una-calculadora-en-70-lineas"><h1>Ap&#233;ndice: Todo el c&#243;digo en uno: una calculadora en 70 l&#237;neas</h1><p>Este es el c&#243;digo final:</p> <div class="highlight"><pre><span class="sd">'''A Calculator Implemented With A Top-Down, Recursive-Descent Parser'''</span><br /><span class="c"># Author: Erez Shinan, Dec 2012</span><br /><br /><span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">collections</span><br /><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span><span class="n">sub</span><span class="p">,</span><span class="n">mul</span><span class="p">,</span><span class="n">div</span><br /><br /><span class="n">Token</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">'Token'</span><span class="p">,</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'value'</span><span class="p">])</span><br /><span class="n">RuleMatch</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">'RuleMatch'</span><span class="p">,</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'matched'</span><span class="p">])</span><br /><br /><span class="n">token_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">'+'</span><span class="p">:</span><span class="s">'ADD'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span><span class="s">'ADD'</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span><span class="s">'MUL'</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span><span class="s">'MUL'</span><span class="p">,</span> <span class="s">'('</span><span class="p">:</span><span class="s">'LPAR'</span><span class="p">,</span> <span class="s">')'</span><span class="p">:</span><span class="s">'RPAR'</span><span class="p">}</span><br /><span class="n">rule_map</span> <span class="o">=</span> <span class="p">{</span><br />    <span class="s">'add'</span> <span class="p">:</span> <span class="p">[</span><span class="s">'mul ADD add'</span><span class="p">,</span> <span class="s">'mul'</span><span class="p">],</span><br />    <span class="s">'mul'</span> <span class="p">:</span> <span class="p">[</span><span class="s">'atom MUL mul'</span><span class="p">,</span> <span class="s">'atom'</span><span class="p">],</span><br />    <span class="s">'atom'</span><span class="p">:</span> <span class="p">[</span><span class="s">'NUM'</span><span class="p">,</span> <span class="s">'LPAR add RPAR'</span><span class="p">,</span> <span class="s">'neg'</span><span class="p">],</span><br />    <span class="s">'neg'</span> <span class="p">:</span> <span class="p">[</span><span class="s">'ADD atom'</span><span class="p">],</span><br /><span class="p">}</span><br /><span class="n">fix_assoc_rules</span> <span class="o">=</span> <span class="s">'add'</span><span class="p">,</span> <span class="s">'mul'</span><br /><br /><span class="n">bin_calc_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">'*'</span><span class="p">:</span><span class="n">mul</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span><span class="n">div</span><span class="p">,</span> <span class="s">'+'</span><span class="p">:</span><span class="n">add</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span><span class="n">sub</span><span class="p">}</span><br /><span class="k">def</span> <span class="nf">calc_binary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span><br />    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">:</span><br />        <span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">bin_calc_map</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">]</span><br />    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><br /><br /><span class="n">calc_map</span> <span class="o">=</span> <span class="p">{</span><br />    <span class="s">'NUM'</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span><br />    <span class="s">'atom'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">],</span><br />    <span class="s">'neg'</span> <span class="p">:</span> <span class="k">lambda</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="n">num</span><span class="p">):</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="o">-</span><span class="n">num</span><span class="p">)[</span><span class="n">op</span><span class="o">==</span><span class="s">'-'</span><span class="p">],</span><br />    <span class="s">'mul'</span> <span class="p">:</span> <span class="n">calc_binary</span><span class="p">,</span><br />    <span class="s">'add'</span> <span class="p">:</span> <span class="n">calc_binary</span><span class="p">,</span><br /><span class="p">}</span><br /><br /><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span><br />    <span class="k">if</span> <span class="n">tokens</span> <span class="ow">and</span> <span class="n">rule_name</span> <span class="o">==</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>      <span class="c"># Match a token?</span><br />        <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><br />    <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">rule_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="p">()):</span>   <span class="c"># Match a rule?</span><br />        <span class="n">remaining_tokens</span> <span class="o">=</span> <span class="n">tokens</span><br />        <span class="n">matched_subrules</span> <span class="o">=</span> <span class="p">[]</span><br />        <span class="k">for</span> <span class="n">subrule</span> <span class="ow">in</span> <span class="n">expansion</span><span class="o">.</span><span class="n">split</span><span class="p">():</span><br />            <span class="n">matched</span><span class="p">,</span> <span class="n">remaining_tokens</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">subrule</span><span class="p">,</span> <span class="n">remaining_tokens</span><span class="p">)</span><br />            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span><br />                <span class="k">break</span>   <span class="c"># no such luck. next expansion!</span><br />            <span class="n">matched_subrules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span><br />        <span class="k">else</span><span class="p">:</span><br />            <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">rule_name</span><span class="p">,</span> <span class="n">matched_subrules</span><span class="p">),</span> <span class="n">remaining_tokens</span><br />    <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>   <span class="c"># match not found</span><br /><br /><span class="k">def</span> <span class="nf">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span><br />    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">matched</span><span class="p">)</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">rule_map</span> <span class="k">else</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><br /><br /><span class="k">def</span> <span class="nf">flatten_right_associativity</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span><br />    <span class="n">new</span> <span class="o">=</span> <span class="n">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">flatten_right_associativity</span><span class="p">)</span><br />    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">fix_assoc_rules</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">new</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><br />        <span class="n">new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">matched</span><br />    <span class="k">return</span> <span class="n">RuleMatch</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><br /><br /><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span><br />    <span class="n">solutions</span> <span class="o">=</span> <span class="n">_recurse_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">)</span><br />    <span class="k">return</span> <span class="n">calc_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">)(</span><span class="n">solutions</span><span class="p">)</span><br /><br /><span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span><br />    <span class="n">split_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[\d.]+|[</span><span class="si">%s</span><span class="s">]'</span> <span class="o">%</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">token_map</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span><br />    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">Token</span><span class="p">(</span><span class="n">token_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'NUM'</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">split_expr</span><span class="p">]</span><br />    <span class="n">tree</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s">'add'</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">div</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">/</span><span class="n">div</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">tokens</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><br />    <span class="n">tree</span> <span class="o">=</span> <span class="n">flatten_right_associativity</span><span class="p">(</span> <span class="n">tree</span> <span class="p">)</span><br />    <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><br /><br /><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span><br />    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span><br />        <span class="k">print</span><span class="p">(</span> <span class="n">calc</span><span class="p">(</span><span class="nb">raw_input</span><span class="p">(</span><span class="s">'&amp;amp;gt; '</span><span class="p">))</span> <span class="p">)</span><br /></pre></div>  <a href="http://2.bp.blogspot.com/-bO23mo8zZPg/UT8wlDzqNFI/AAAAAAAACD0/ckWOWR3rF2s/s1600/close_quote.png"><img alt="Termina la traducci&#243;n" border="0" height="40" src="http://2.bp.blogspot.com/-bO23mo8zZPg/UT8wlDzqNFI/AAAAAAAACD0/ckWOWR3rF2s/s320/close_quote.png" width="48" /></a> <p>Hasta aqu&#237; el art&#237;culo original. Si quieres que traduzca el art&#237;culo anterior al que se hace referencia en el texto, d&#233;jame una nota en los comentarios.</p></div>
    </div>
</div></div>
<div class="time">
<h3>15:42</h3>
<div class="item feed-207d1418 feed-{feed_id}" id="item-a7704e8d">
<p class="itemheader">
<span class="itemtitle">
    El Ornitorrinco Enmascarado:
<a href="http://www.elornitorrincoenmascarado.com/2013/03/pygments-embellece-tu-codigo-fuente.html">Pygments: Embellece tu c&#243;digo fuente</a></span>
</p>
    <div class="itemdescription">
    <p><a href="http://pygments.org/"><img border="0" src="http://3.bp.blogspot.com/-IMKYREvgdPE/UUCL44I_TlI/AAAAAAAACEs/E0V1z_0vO0E/s320/pygments-logo.png" style="float: right;" /></a><p><a href="http://pygments.org/"><b>Pygments</b></a> es una librer&#237;a, <i>plugin</i> y utilidad, todo en uno, que nos permite <i>embellecer</i> nuestro c&#243;digo, a&#241;adiendo resaltado de palabras claves y colores que facilitan la lectura del mismo. Es especialmente &#250;til para foros, <i>wikis</i>, <i>blogs</i> o cualquier sistema de ense&#241;anza <i>on-line</i> que necesiten mostrar c&#243;digo fuente. por ejemplo, lo usa mi repositorio de c&#243;digo favorito, <a href="http://bitbucket.org/">bitbucket</a>.</p> <p>Pygments est&#225; escrito en Python, pero entiende muchos tipos de lenguaje, incluyendo los lenguajes de programaci&#243;n m&#225;s populares como Python, Ruby, JavaScript, C, C++, C#, Java, Lua, Perl, lenguajes cl&#225;sicos como Pascal, Common Lisp o Fortran, lenguajes nuevos como CoffeeScript o Clojure, lenguajes de plantillas como los de Django, Jinja, ERB (Ruby templating), Mako o Myghty y mil cosas m&#225;s: ficheros de configuraci&#243;n de Apache, hojas de estilo CSS, SQL, etc... Esta variedad viene dada por lo sencillo que resulta escribir nuevos analizadores l&#233;xicos; la mayor&#237;a de los lenguajes solo necesitan definir algunas expresiones regulares.</p> <p>Puede usarse como herramienta de l&#237;nea de comandos: <code>pygmentize</code>, como librer&#237;a para uso interno o como <i>plugin</i> o a&#241;adido para sistemas ya existentes: Wordpress, MoinMoin y REsT entre otros. Es muy f&#225;cil tanto de utilizar como de extender; puedes <a href="http://pygments.org/docs/styles/">personalizar la hoja de estilos</a> para reflejar tus gustos est&#233;ticos (Pero recuerda, marr&#243;n y azul rara vez combinan). La salida m&#225;s com&#250;n es Html, pero tambi&#233;n podemos obtener la salida en RTF, LaTex o c&#243;digos ANSI para la consola.</p> <p>Para integrarlo con Blogger us&#233; la l&#237;nea de comandos para obtener los estilos CSS correspondientes (<code>pygmentize -f html -S colorful</code>) y los inclu&#237; en mi plantilla.</p> <p>Como creo fervientemente en las virtudes did&#225;cticas de los ejemplos, he aqu&#237; un cacho de c&#243;digo Python (&#161;Mi primer c&#243;digo publicado en Python 3!) antes de Pygments:</p> <pre><br />granos = 1<br />for escaque in range(1, 65):<br />    print ("En el escaque #{0} hay #{1} granos".format(escaque, granos))<br />    granos *= 2<br /></pre> <p>Y despu&#233;s:</p> <div class="highlight"><pre><span class="n">granos</span> <span class="o">=</span> <span class="mi">1</span><br /><span class="k">for</span> <span class="n">escaque</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">65</span><span class="p">):</span><br />    <span class="k">print</span> <span class="p">(</span><span class="s">"En el escaque #{0} hay #{1} granos"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escaque</span><span class="p">,</span> <span class="n">granos</span><span class="p">))</span><br />    <span class="n">granos</span> <span class="o">*=</span> <span class="mi">2</span><br /></pre></div> <p>Veamos otro ejemplo, esta vez con Ruby. Antes:</p> <pre><br />granos = 1<br />64.times do |escaque|<br />    puts "En el escaque #{escaque+1} hay #{granos} granos"<br />    granos *= 2<br />    end<br /></pre> <p>Y despu&#233;s:</p> <div class="highlight"><pre><span class="n">granos</span> <span class="o">=</span> <span class="mi">1</span><br /><span class="mi">64</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">escaque</span><span class="o">|</span><br />    <span class="nb">puts</span> <span class="s2">"En el escaque </span><span class="si">#{</span><span class="n">escaque</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> hay </span><span class="si">#{</span><span class="n">granos</span><span class="si">}</span><span class="s2"> granos"</span><br />    <span class="n">granos</span> <span class="o">*=</span> <span class="mi">2</span><br />    <span class="k">end</span><br /></pre></div><p>&nbsp;</p>
    </div>
</div></div>
</div>

</div>
<div id="feedstats">
    <div id="xmls">
        
    <a href="foafroll.xml"><img src="foaf.png" title="FOAF" alt="FOAF" /></a>
    <a href="opml.xml"><img src="opml.png" title="OPML" alt="OPML" /></a>
    <a href="rss.xml"><img src="rss.png" title="RSS" alt="RSS" /></a>

    </div>
    <h2 id="feedmain"><a href="http://es.python.org" style="color: black; font-size: 20px; text-decoration: none;"><span style="color:#d40000">e</span><span style="color:#f3b52c">s</span>.<span style="color:#43648b">pyt</span><span style="color:#f3b52c">hon</span>.org</a></h2>
    <h2 id="feedlaststatus">Estado</h2>
    <div id="log">
        
    <a href="log.html">Estado de fuentes</a>

    </div>
    <h2 id="feedsarchive">Archivo</h2>
    <div id="archive">
        <table class="calendar">
<tr class="cal-head">
<td class="cal-prev"><a href="index-2013-02-27.html">&lt;</a></td>
<td class="cal-month" colspan="5">marzo 2013</td>
<td class="cal-next"><a href="index-2013-04-06.html">&gt;</a></td>
</tr>
<tr class="cal-days">
<th>lun</th><th>mar</th><th>mi&#233;</th><th>jue</th><th>vie</th><th>s&#225;b</th><th>dom</th></tr>
<tr class="cal-week">
<td class="cal-day"><em class="cal-othermonth">25</em></td><td class="cal-day"><em class="cal-othermonth">26</em></td><td class="cal-day"><em class="cal-othermonth">27</em></td><td class="cal-day"><em class="cal-othermonth">28</em></td><td class="cal-day"><a class="cal-link" href="index-2013-03-01.html">01</a></td><td class="cal-day">02</td><td class="cal-day">03</td></tr>
<tr class="cal-week">
<td class="cal-day">04</td><td class="cal-day">05</td><td class="cal-day">06</td><td class="cal-day">07</td><td class="cal-day">08</td><td class="cal-day">09</td><td class="cal-day">10</td></tr>
<tr class="cal-week">
<td class="cal-day">11</td><td class="cal-day"><a class="cal-link" href="index-2013-03-12.html">12</a></td><td class="cal-day"><strong class="cal-current">13</strong></td><td class="cal-day">14</td><td class="cal-day">15</td><td class="cal-day"><a class="cal-link" href="index-2013-03-16.html">16</a></td><td class="cal-day">17</td></tr>
<tr class="cal-week">
<td class="cal-day">18</td><td class="cal-day">19</td><td class="cal-day">20</td><td class="cal-day">21</td><td class="cal-day"><a class="cal-link" href="index-2013-03-22.html">22</a></td><td class="cal-day">23</td><td class="cal-day">24</td></tr>
<tr class="cal-week">
<td class="cal-day"><a class="cal-link" href="index-2013-03-25.html">25</a></td><td class="cal-day">26</td><td class="cal-day">27</td><td class="cal-day">28</td><td class="cal-day">29</td><td class="cal-day">30</td><td class="cal-day">31</td></tr>
</table>

    </div>
    <h2 id="feedsblogs">Blogs</h2>
    <div id="feedlist">
        
    
<a href="http://maengora.blogspot.com/search/label/python">Actualidad Informatica</a>
<a href="http://maengora.blogspot.com/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">Alfffa Solutions</a>
<a href="http://alfffa.net/blog/category/informatica/programacion/python/feed/"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">codeplasticlesthack</a>
<a href="http://lesthack.com.mx/category/programacion/python/feed/"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">Dead Epsilon</a>
<a href="https://juanlu001.github.io/rss.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://www.eferro.net/search/label/Python">e-ferro</a>
<a href="http://www.eferro.net/feeds/posts/default/-/Python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://www.atareao.es">El Atareao</a>
<a href="http://feeds.feedburner.com/ElAtareao_python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://www.elornitorrincoenmascarado.com/search/label/python">El Ornitorrinco Enmascarado</a>
<a href="http://www.elornitorrincoenmascarado.com/feeds/posts/default/-/python/?alt=rss"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://elviajedelnavegante.blogspot.com/search/label/python">El viaje del navegante</a>
<a href="http://elviajedelnavegante.blogspot.com/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://www.freakspot.net/">Freak Spot</a>
<a href="https://www.freakspot.net/feeds/python.atom.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">Frogblog</a>
<a href="http://blog.willinux.net/?cat=14&feed=rss2"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://www.genbetadev.com">Genbeta:dev</a>
<a href="https://www.genbetadev.com/categoria/python/rss2.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://blog.ch3m4.org/">Hyperreals *R</a>
<a href="http://blog.ch3m4.org/feeds/python.atom.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">JavAguirre.net</a>
<a href="http://javaguirre.me/python.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://blep.blogspot.com/search/label/python">Javier Santana</a>
<a href="http://blep.blogspot.com/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://joedicastro.com">joe di castro</a>
<a href="http://joedicastro.com/rss.xml"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://blog.crespo.org.ve/search/label/python">La libertad de desarrollar...</a>
<a href="http://blog.crespo.org.ve/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">Monobot</a>
<a href="http://monobotblog.alvarezalonso.es/archives/category/python/feed"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://mundo-python.blogspot.com/">Mundo Python</a>
<a href="http://mundo-python.blogspot.com/feeds/posts/default"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://www.userlinux.net">oscarmlage</a>
<a href="https://userlinux.net/tag-python/feed/"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://pybonacci.wordpress.com">Pybonacci</a>
<a href="https://pybonacci.wordpress.com/feed/"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://blog-es.python.org/">Python Insider ES</a>
<a href="http://feeds.feedburner.com/PythonInsiderES"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="">Read The Fucking Docs</a>
<a href="http://readthefuckingdocumentation.blogspot.com/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="http://simelo-es.blogspot.com/search/label/python">Simelo pides...</a>
<a href="http://simelo-es.blogspot.com/feeds/posts/default/-/python"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://beastieux.com">The::Beastieux</a>
<a href="https://beastieux.com/category/python/feed/"><img src="feed-icon.png" alt=""/></a>
<br />
<a href="https://unoyunodiez.com">Uno y uno = diez</a>
<a href="https://unoyunodiez.com/tag/python-2/feed/"><img src="feed-icon.png" alt=""/></a>
<br />

    </div>
</div>
<div id="footer">
<p id="aboutrawdog">Generado por
<a href="http://offog.org/code/rawdog.html">rawdog</a>
version 2.22rc1
by <a href="mailto:ats@offog.org">Adam Sampson</a>.</p>
<p>Theme por <a href="http://code.joedicastro.com/my-rawdog-planet">joe di castro</a>. Basado en el <a href="http://github.com/ralsina/planeta-pyar/tree/master">trabajo de Roberto Alsina</a> para PyAr</p>
<p>


</p>
</div>
</body>
</html>
